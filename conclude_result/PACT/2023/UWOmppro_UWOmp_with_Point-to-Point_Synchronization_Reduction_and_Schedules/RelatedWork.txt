相关工作总结：

1、现有方法一：UWOpenMP/UWOmp++/UWOmp 𝑝𝑟𝑜系列
核心思想: 
- 提出独特工作者模型（UWOpenMP），使程序员感知每个并行循环迭代由独立线程执行
- 支持在并行循环内插入屏障语句（UWOmp++扩展至递归函数）
- UWOmp 𝑝𝑟𝑜进一步支持：迭代间的点对点同步、并行循环内的归约操作、任意OpenMP调度策略

主要局限性: 
- 依赖共享变量而非任务本身进行同步（对比其点对点同步优势）
- 归约操作需等待并行区域结束才能获取结果（对比其中间归约特性）

2、现有方法二：基于continuation的并行程序扩展
核心思想:
- 使用continuation显式维护所有活动的激活记录
- 通过存储/恢复激活记录实现活动暂停与恢复
- 典型案例包括：Cilk语言的基于C运行时的工作窃取调度器

主要局限性:
- 全量激活记录维护导致内存开销过大
- 特定场景限制（如HJ的OSDeCont仅适用于help-first/work-first工作窃取策略）

3、现有方法三：OpenMP原生任务机制
核心思想:
- 通过#pragma omp task指令创建任务
- 使用带depend子句的taskwait实现任务同步

主要局限性:
- 同步粒度限于共享变量级（无法实现迭代级精确控制）
- 缺乏对并行循环内递归函数的全面支持

研究缺口：
1. 内存效率问题：现有continuation方案存在不必要的内存分配开销
2. 调度灵活性不足：部分方案受限于特定调度策略（如work-first/help-first）
3. 同步粒度粗糙：主流方案无法支持迭代级点对点同步
4. 即时计算支持缺失：归约操作需等待并行区域结束才能获取结果

注：本文工作通过以下方式突破限制：
(1) 采用精简闭包数据结构替代全量激活记录
(2) 内存重用机制减少malloc调用
(3) 通用化continuation技术适配任意调度策略
(4) 实现中间归约即时可用性