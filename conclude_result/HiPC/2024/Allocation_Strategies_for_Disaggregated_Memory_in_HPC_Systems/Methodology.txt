方法概述：

1、方法名称: 
- Priority Algorithm (基于优先级的算法)
- Stochastic Algorithm (基于随机内存配置文件的算法)

2、核心思想:
- Priority Algorithm: 通过动态排序运行中的应用程序（按计算资源需求与内存需求的比值降序排列），优先为高优先级应用分配内存，以最大化系统吞吐量。适用于内存行为可预测的场景。
- Stochastic Algorithm: 基于历史数据或已知的随机内存配置文件，通过贪心策略分配内存以最大化期望吞吐量。适用于内存需求动态变化的场景。

3、主要流程/组件:

**Priority Algorithm:**
1. **排序模块**: 在任意时间点 \( t_0 \)，按 \( c_i / m_i(t_0) \) 对运行中的应用降序排序（\( c_i \) 为计算节点需求，\( m_i \) 为内存需求）。
2. **内存分配模块**: 从排序列表的头部开始，依次为应用分配所需内存（不超过其需求上限），直到可用内存耗尽。

**Stochastic Algorithm:**
1. **初始化模块**: 为每个应用分配初始零内存，并计算初始优先级值 \( G[i] = c_i \cdot \sum_{j \geq 1} p_j^{(i)} / m_j^{(i)} \)（基于随机变量 \( X \) 的离散分布）。
2. **贪心分配模块**: 
   - 按优先级值 \( G[i] \) 升序处理应用。
   - 逐步增加应用的内存分配至下一阈值 \( m_{j+1}^{(i)} \)，直到总内存限制或所有应用达到最大需求。
3. **动态更新模块**: 每次分配后更新应用的优先级值和剩余可用内存。

**对比基线算法:**
1. **Aggregated**: 按计算资源占比静态分配内存（模拟传统聚合内存行为）。
2. **Oldest-First/Largest-First**: 分别按到达时间或任务规模排序的优先级策略。

**关键关系:**
- Priority Algorithm 依赖实时准确的内存需求信息，而 Stochastic Algorithm 利用统计分布处理不确定性。
- 两者均通过线性插值模型计算因内存不足导致的性能降速（公式 \( SL_i(M_i, j) = \alpha + (1-\alpha) \min(1, M_i/m_j) \)），其中 \( \alpha \) 为慢速存储与快速存储的带宽比。