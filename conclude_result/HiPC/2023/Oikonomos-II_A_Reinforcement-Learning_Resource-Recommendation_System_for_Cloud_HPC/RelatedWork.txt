相关工作总结：

1. 现有方法一：搜索型算法（Search-based algorithms）
核心思想: 通过连续评估不同硬件组合来寻找最优选择，不依赖历史数据，但需要多次运行任务以找到最优实例类型。
主要局限性: 
- 需要多次运行任务，导致额外成本
- 存在探索与利用的权衡问题（如Scout、Arrow、Micky等方法所示）
- 所有搜索型算法都需要多次运行工作负载

2. 现有方法二：预测型算法（Prediction-based algorithms）
核心思想: 使用离线数据评估来预测性能，可立即推荐最优实例类型，无需主动搜索。
主要局限性:
- 需要应用行为模型或历史数据
- 存在建模特异性与数据依赖性之间的权衡

2.1 子类方法：Ernest
核心思想: 使用非负最小二乘求解器，基于输入数据大小、虚拟机数量和执行时间的历史数据进行公式拟合。
主要局限性:
- 不适用于应用行为未知的情况
- 不适合异构硬件配置（仅考虑机器数量）

2.2 子类方法：Daleel
核心思想: 使用多元多项式模型预测执行时间，通过回归方法拟合训练数据。
主要局限性:
- 不适合异构硬件配置
- 难以处理输入参数与执行时间之间的复杂关系

2.3 子类方法：PARIS
核心思想: 将实例性能特征与工作负载特定资源需求解耦，通过基准测试分析实例类型和应用指纹。
主要局限性:
- 需要用户选择代表性工作负载
- 未考虑应用参数值对资源使用模式的影响

2.4 子类方法：Tamakkon
核心思想: 使用Kolmogorov-Smirnov测试确定相似性，基于相似应用的性能数据进行推荐。
主要局限性:
- 需要生成辅助数据（额外成本）
- "相似性"定义过于笼统

2.5 子类方法：A2Cloud-RF/A2Cloud-H
核心思想: 
- A2Cloud-RF：使用随机森林分类器分别分析实例性能和应用资源使用情况
- A2Cloud-H：分层使用多种机器学习算法（无监督+有监督学习模块）
主要局限性:
- A2Cloud-RF的四级分类过于粗糙
- A2Cloud-H系统复杂度增加（需要额外算法选择推荐算法）
- 难以捕捉应用性能、资源使用和可用硬件间的复杂交互

3. Oikonomos（作者先前工作）
核心思想: 使用多层感知器(MLP)神经网络，基于作业参数值和硬件特征预测执行时间。
主要局限性:
- 依赖大量历史数据（对新应用不实用）
- 神经网络对数据不平衡问题特别敏感

研究缺口总结：
1. "探索与利用"的固有矛盾：搜索型算法需要在推荐准确性和开销成本之间权衡
2. "建模特异性与数据依赖性"的权衡：预测型算法需要在精确建模和数据需求之间平衡
3. 异构硬件配置支持不足：多数现有方法难以处理复杂的异构环境
4. "冷启动"问题：新应用缺乏历史数据时表现不佳
5. 用户负担问题：部分方法需要用户提供代表性工作负载