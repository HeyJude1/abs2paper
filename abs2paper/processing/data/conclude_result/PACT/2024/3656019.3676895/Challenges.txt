### 核心挑战总结：

#### 挑战一：**代码表示的多样性与复杂性**
**分析**:  
- **具体内容**: 现有代码表示方法（如基于词法标记的序列表示）难以同时捕获程序的语法结构、语义信息和程序依赖关系（如数据流、控制流、调用流）。  
- **根源**:  
  1. **问题复杂性**: 程序本身具有多维度特性（语法、语义、结构），单一表示无法全面覆盖。  
  2. **技术瓶颈**: 传统方法依赖手工设计特征或单模态表示（如仅文本或仅图），缺乏多模态融合能力。  

#### 挑战二：**跨任务通用性与资源开销**  
**分析**:  
- **具体内容**: 现有基于LLVM IR的表示方法需要为每个下游任务定制复杂模型（如GNNs），导致资源密集且难以迁移。  
- **根源**:  
  1. **技术瓶颈**: 缺乏统一的预训练框架，导致任务特异性建模需求高。  
  2. **数据限制**: 传统方法需要大量标注数据或多次代码执行（如Auto-Tuning），成本高昂。  

#### 挑战三：**多模态对齐与联合建模**  
**分析**:  
- **具体内容**: 如何将代码的文本形式（IR语句）与图形式（数据/控制/调用流图）有效关联，以统一理解代码的语法、语义和结构。  
- **根源**:  
  1. **问题复杂性**: 不同模态间存在异构性（文本vs图），需设计跨模态对齐机制。  
  2. **技术空白**: 现有预训练模型（如CodeBERT）仅处理双模态（代码-自然语言），未解决代码内部多模态对齐问题。  

---

### 补充说明：
1. **关键矛盾点**：论文强调传统方法在“通用性”与“性能”间的权衡——手工特征或单模态表示虽针对特定任务有效，但无法适应多样化HPC优化场景。  
2. **创新突破口**：通过自监督多模态预训练（MIREncoder）统一语法与语义建模，并引入IR-Graph Matching任务解决跨模态对齐难题。