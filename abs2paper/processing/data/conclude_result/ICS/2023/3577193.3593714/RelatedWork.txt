相关工作总结：

1、现有方法一：Performance Modeling and Extrapolation（性能建模与外推）
核心思想: 通过机器学习（如MLP）或启发式方法对应用程序或子程序性能进行预测，重点关注执行时间的准确预测，而非优化转换的选择。部分工作通过小规模实验的时间测量来建模运行时参数依赖性。
主要局限性: 未聚焦于优化转换及其选择策略；对复杂架构的适应性不足，且缺乏对分布式环境下执行成本的考量。

2、现有方法二：Polyhedral Compilers（多面体编译器）
核心思想: 将性能优化问题转化为整数线性规划（ILP），基于目标架构的手工设计成本模型求解。代表工具有Pluto、PENCIL和LLVM Polly。
主要局限性: 为保证ILP可解性，成本模型需强简化假设，导致在复杂架构上表现次优。

3、现有方法三：Deep Code Representations（深度代码表示）
核心思想: 通过静态代码嵌入（如inst2vec、ProGraML等）解决典型编译器任务，或根据语义分类应用。性能嵌入则旨在捕获与底层算法无关的静态和动态性能特征。
主要局限性: 现有方法多面向通用编译器任务，对性能特征的针对性编码能力有限。

4、现有方法四：Optimizing Compilers（优化编译器）
核心思想: 基于静态特征（Tiramisu/Halide/TVM）或图神经网络（Singh et al.）构建深度学习性能模型，指导调度空间搜索；部分工作将搜索问题重构为马尔可夫决策过程（Steiner et al.），或通过分类问题选择优化策略（如Elafrou et al.稀疏线性代数优化）。
主要局限性: 模型与优化强耦合导致搜索复杂度高；优化空间扩展需重新训练模型；依赖特定输入和分析特征。

5、现有方法五：Transfer Tuning（迁移调优）
核心思想: 基于静态特征聚类函数（Martins et al.）或手工启发式规则（Gibson & Cano）复用张量程序中特定操作的优化配置。
主要局限性: 依赖人工设计的迁移规则，泛化能力受限；未充分利用中间表示的语义信息。

研究缺口：
- 现有方法普遍缺乏将性能建模与优化解耦的机制，导致搜索复杂度高且扩展性差。
- 多面体编译器的简化假设限制了其在复杂架构上的优化效果。
- 迁移调优依赖人工规则，缺乏基于语义相似性的自动化泛化能力。
- 多数工作未解决离线优化数据库的构建与本地搜索的结合问题。