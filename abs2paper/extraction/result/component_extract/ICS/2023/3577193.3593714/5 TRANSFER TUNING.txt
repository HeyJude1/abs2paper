5 TRANSFER TUNING
Peephole optimization is a compiler technique that replaces a local window of instructions with an equivalent set. Such local windows are usually found using a pattern-matching algorithm. However, since the replacement rules of peephole optimizations are designed for bit-exactness, the applicability of the optimization is limited to small windows of a few instructions. Our transfer tuning algorithm extends the idea of peephole optimizations to larger loop nests by fuzzy matching program transformations from one loop nest to another via similar node embeddings.
5.1 A Matching Problem for Program Transformations
Transferring a transformation from a source loop nest to a target loop nest requires identifying the corresponding instructions, to which the transformation shall be applied in the target. As an example, consider the pair of loop nests in Figure and a transformation that marks a loop for parallel execution. To transfer it to the target loop nest, the corresponding loop must be identified. Since parallel for (int i=1; i < 10000; i++)
A[i] = B[i-1] + B[i] + B[i+1];
#pragma omp parallel for for (int i=1; i < 10000; i++)  loop nests are represented by graphs in our model, instructions correspond to nodes and edges of the graph. Furthermore, since the node embeddings generated by the model have a one-to-one correspondence with the nodes in the IR, transformations shall be transferred from the source to the target parallel loop nest by a matching of the node embeddings, as illustrated in Figure . In detail, the transfer tuning algorithm consists of four steps:
A[i] = B[i-1] + B[i] + B[
(1) Let ðº ð¿ = (ð‘‰ ð¿ , ð¸ ð¿ ) be the source parallel loop nest and let ðº ð‘‡ = (ð‘‰ ð‘‡ , ð¸ ð‘‡ ) be the induced subgraph for a transformation ð‘‡ . We compute the source node embeddings ð‘’ð‘šð‘ð‘  ð‘† for each ð‘£ âˆˆ ð‘‰ ð‘‡ . (2) Let ðº ð¿ â€² = (ð‘‰ ð¿ â€² , ð¸ ð¿ â€² ) be the target parallel loop nest. We compute the target node embeddings ð‘’ð‘šð‘ð‘  ð‘‡ for each ð‘£ âˆˆ ð‘‰ ð¿ â€² . (3) Let ð‘€ = (ð‘‰ ð¿ â€² , ð‘‰ ð‘‡ ; ð¸, ð¶) be a complete, bi-partite graph between the source subgraph's nodes ð‘‰ ð‘‡ and the target nodes ð‘‰ ð¿ â€² , where ð¶ is the cost matrix of the pair-wise â„“ 2 distances between ð‘’ð‘šð‘ð‘  ð‘‡ and ð‘’ð‘šð‘ð‘  ð‘† . We solve the matching problem ð‘€ using the Hungarian method obtaining the mapping between source subgraph's nodes ð‘‰ ð‘‡ and the target subgraph's nodes ð‘‰ â€² ð‘‡ âŠ† ð‘‰ ð¿ â€² . (4) The transformation ð‘‡ â€² can now be instantiated from ð‘‰ â€² ð‘‡ and be applied on ðº ð¿ â€² accordingly .
A program transformation can thereby range from a simple change of a node's property to a complex rewrite of a subgraph. For instance, a tiling transformation may split the nodes of a map into a pair of maps with corresponding edges. For sequences of transformations, the four steps are repeated for every new source and target parallel loop nest of each step. If the matching problem cannot be solved or the resulting matching does not yield a valid subgraph for the specific transformation, the transformation is skipped. In practice, we add further constraints to the cost matrix, e.g., setting the cost to infinity for pairs of nodes that do not have the same type. Furthermore, each transformation requires specific handling of its properties. For instance, a tiling transformation may not evenly divide the target loop extents.