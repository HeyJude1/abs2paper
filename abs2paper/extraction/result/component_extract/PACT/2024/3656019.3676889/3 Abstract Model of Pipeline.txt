3 Abstract Model of Pipeline
We have developed a DSL that enables relatively high-level specifications that focus on functionality more than cycle-accurate behavior.
The DSL allows the architect to model the core pipeline as an interconnected group of queue-based structures that each have one or more entries. Because our DSL describes queue-based structures, we call it A Queue Language (AQL). Structures can communicate with each other by sending messages or signals.
Commonly used pipeline structures include the physical register file, reorder buffer (ROB), instruction queue (IQ), load queue (LQ), store queue (SQ), load-store-queue (LSQ), post-commit write buffer (WB), etc. Structures with multiples entries may have an entry ordering, such as FIFO.
Each structure entry is logically a state machine. Each entry has a state (that is initialized to a specified initial state) that consists of one or more fields. An event (i.e., the arrival of a message from another structure) can cause an action and possibly a transition of that entry to a new state. An event satisfies one or more conditions that guard actions/transitions, as illustrated in Figure . We illustrate the state machine for Design-1's LQ in Figure which is self-explanatory.
3.2 Memory Instructions: Instruction States and Sub-Operations
To faciliate PipeGen's analysis and transformation algorithms, AQL considers every memory instruction to start in an initial instruction state and undergo a sequence of sub-operations that change its state.  The state machine and state fields of Design-1's LQ entries. Each LQ entry first awaits a load to be inserted in state WaitingForLoadInst. After receiving a load, the entry progresses to performing sub-operations (highlighted in color) such as issuing the load, waiting for it's response, and writing it's result before waiting to be committed. Some states are simplified away, represented by a dotted line.
3.2.1 Instruction
of a load or store is ReadyToDispatch. The sequence of subsequent states for a load that is not misspeculated are: Dispatched, ReadyToIssue, WaitingForResponse, WritingToRegister, and ReadyToCommit. If the load is misspeculated in either Waiting-ForResponse or ReadyToCommit, its state changes to an earlier state in the sequence depending on the core design. The ordered sequence of subsequent states for a store are: Dispatched, StoreVal-ueReady, ReadyToCommit, ReadytoIssue and WaitingForResponse. The ordered sequence for a fence is: ReadyToDispatch, Dispatched and ReadyToCommit.
An instruction state transition can either be a progression (i.e., proceeding in sequence order) or a reset (i.e., returning to an earlier state in the sequence). This ordering enables PipeGen to find memory operations that are older (i.e., have not progressed as far in their instruction state sequences). Architects can define additional, noncanonical states for their own purposes, but any user-defined state between two canonical states is effectively equal to the previous canonical state.
3.2.2 Sub-operations. AQL considers every memory operation
to perform a subset of a canonical set of sub-operations, each of which is a keyword in AQL. These sub-operations are: dispatch, issue_load_request, receive_response, issue_write_request, write_load_result, and commit.
Explicitly using these canonical instruction states and suboperations is critical to PipeGen. At its heart, enforcing memory ordering in the pipeline is all about controlling when and how these sub-operations occur. As we discuss later, adding stalls or replays (or other logic to enforce an MCM) requires PipeGen to identify when to issue to the memory system, when to replay loads, etc.
3.3 AQL Programming Requirements
PipeGen requires the architect to specify instruction states and suboperations such that it can perform its analyses and transformations. There are several programming guidelines that must be followed. The programmer must:
• Label the canonical sub-operations. PipeGen then identifies the canonical instruction states corresponding to the suboperations, thereby labeling the canonical instruction states. One of the primary motivations for developing AQL instead of using an existing hardware description language (HDL) is that existing HDLs would not necessarily make instruction states explicit. (They could be implicitly derived from the state of the pipeline, but that would greatly complicate PipeGen.) • Label a transition with the appropriate label, described in Section 3.2.1, and illustrated in Figure . • Handle instruction misspeculation.
• Label the message that the single-core design uses for squashing misspeculation.
3.4 Case Study: AQL for the LQ in Design 1
In Listing 1, we provide a snippet of AQL code to provide a sense of what it looks like. The snippet includes the code that describes two canonical instruction states in Design-1's LQ. In each state, the user specifies what event (i.e., message or signal) the structure is waiting for before it transitions to its next instruction state.