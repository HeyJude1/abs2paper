4 Transformations
Akin to a compiler, the core of PipeGen consists of algorithms for analyzing the input design and transforming it to enforce the desired MCM. In this section, we describe how PipeGen automatically adds the three MCM enforcement mechanisms presented in Section 4.
The choice of which transformations to perform depends on both the user's desired consistency model and the user's preference for the type of MCM enforcement mechanism.
4.1 In-Order Memory Instructions
Consider two memory instructions, M1 and M2, where M1 is before M2 in program order. To enforce in-order execution of two memory instructions M1 → M2, the pipeline must stall M2 until M1 has completed. This enforcement of in-order execution can be used to provide whatever orderings are required by the desired MCM.
To implement this transformation, PipeGen must:
• Identify the M2 instruction state in which M2 should stall. ReadyToIssue performs the sub-operation issue_load_request and transitions to WaitingForReponse. WaitingForResponse waits for the memory system to respond with the load's value in the sub-operation receive_response, then transitions to WriteToRegister. Both states shown are wrapped in a listen-handle block, to handle misspeculation by resetting the entry's state to WaitingForLoadInst.
• Add logic to stall and then un-stall M2 in these identified states. PipeGen needs to identify M1's post-memory completion states. The post-memory completion states refer to the set of states after the memory instruction has globally performed. For a load and a store, the post-completion states are all states after WaitingForResponsei.e., all states after a memory response has been received. For a fence, the post-completion states are all states after ReadyToCommit. Once again, because these instruction states are labeled in AQL, it is simple for PipeGen to find their successors. Specifically, PipeGen extracts the instruction state graph from the input AQL code. As discussed in Section 3.2.1, in AQL each instruction has a set of states that it can be in and transitions between these states-we call this an instruction state graph. PipeGen then performs a reachability analysis to compute M1's post-completion states.
4.1.3 Adding Logic to Stall M2 in its Memory
Access State and Unstall it in M1's Memory Completion State. When M2 is in its memory access state, the pipeline must stall M2 if M1 is in any instruction state prior to its memory completion state. Thus, PipeGen makes the following transformations:
• Adds logic to the structure that holds M2 when M2 is in its memory access state (or any state before it if stalling at access state causes a deadlock), and this logic queries all structures that can hold M1 in a pre-completion state.
• Adds logic to the structure holding M2 to stall M2 until receiving a subsequent un-stall message from a structure holding M1 in a pre-completion state. • Adds logic to all structures that can hold M1 in a precompletion state, and this logic sends an un-stall message to the structure holding M2 when M1 changes its instruction state to its completion state. This stall we add is conservative in that not all controllers that can hold M1 in a pre-complete state need to be queried. For example, in Design-1, a load is inserted in the IQ, LQ, and ROB, and has state in all of these controllers. Querying all of these controllers' state is redundant, because the LQ holds all in-flight loads and their instruction states. The IQ and ROB do not contribute any information about loads beyond what the LQ already has.
4.2 Load-Replay
The load replay transformation has the pipeline replay each load at ReadyToCommit (reusing the originally computed address) and compare the replayed value to the value that was returned from the memory system when the load earlier executed speculatively. To implement this transformation, PipeGen must:
• Add logic to re-issue each load to the memory system when the load is ready to commit. • Identify where the original, speculative value is held.
• Add logic to compare the replayed load value to the original, speculative value. If the values differ, the logic must use the misspeculation recovery logic provided by the user for recovering from single-core misspeculation.
4.2.1 Adding Logic to Replay Loads. PipeGen must first identify
where in the pipeline loads are issued to the memory system. Because the user labels the canonical instruction states, PipeGen can find where a load transitions from ReadyToIssue to WaitingForResponse; this transition occurs in the structure that issues loads. We refer to this structure as the load-issuing structure. PipeGen adds logic to the load-issuing structure to make it perform the replay load. If the system contains a structure that holds committed writes before they are written to memory, such as a post-commit write buffer (WB), that structure is logically part of the memory system and it is queried at replay. (PipeGen is able to identify whether or not an input pipeline has a post-commit WB by performing reachability analysis on post-commit store states.) To identify whether there is a post-commit WB, once again PipeGen extracts the instruction state graph-this time of a store instruction. PipeGen then performs a reachability analysis starting from the store's ReadyToCommit state, and identifies the set of postcommit states of the store. Within the post-commit states of the store, PipeGen searches for the ReadyToIssue and WaitingForResponse states, and a match indicates the presence of a post-commit WB.
PipeGen must similarly identify where in the pipeline that loads commit, which we refer to as the commit structure. At that location, PipeGen adds logic to send a message from the commit structure to the load-issuing structure, requesting a load to be issued and stalling until the response from the memory system arrives at the load-issuing structure.
4.2.2 Identifying
Where the Original Load Value Is. PipeGen searches for the sub-operation keyword write_load_result. The structure that includes that keyword is the structure that holds the data that has been returned by the memory system.
4.2.3 Adding Logic to Compare the Original Value to the Replayed
Value. PipeGen identifies the structure where a load commits, using the commit sub-operation keyword. PipeGen adds logic there to (a) send a message to the structure that holds the originally read value of the load, requesting a response with the original value, (b) send a message to the load-issuing structure to replay the load and receive a newly read value, (c) compare the two values, and (d) if the values differ, trigger the single-core misspeculation recovery mechanism.
4.3 Invalidation Tracking
The invalidation tracking transformation observes incoming coherence invalidations and compares their addresses to the addresses of in-flight loads that have already speculatively executed. To implement this transformation, PipeGen makes the following transformation:
• Adds a structure to track the addresses of speculative loads.
• Adds logic to compare the addresses of speculative loads to the addresses of incoming coherence invalidations.
4.3.1 Adding Structure to Track Addresses of Speculative Loads.
PipeGen adds a structure whose entries are the addresses (and sequence numbers) of loads that have already been speculatively executed. The entries of this structure, which we refer to as Load-Tracker, are unordered. LoadTracker can be queried by address, and it accepts messages for adding and removing entries. PipeGen adds logic to (a) add an entry whenever a load performs the suboperation issue_load_request and (b) remove an entry whenever a load performs the sub-operation commit. LoadTracker can also accept messages to reset it (i.e., clear all of its entries).
4.3.2 Adding Logic to Compare Addresses of Speculative Loads to
Invalidations. PipeGen adds logic to the memory system to send the addresses of incoming coherence invalidations to LoadTracker. If there is a match, LoadTracker resets itself and triggers the pipeline's single-core misspeculation mechanism to squash the misspeculated load and all instructions younger than it.