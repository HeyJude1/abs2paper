6 Output: Results and Verification
PipeGen's output is the transformed pipeline with the MCM mechanisms in place. Currently, PipeGen produces this output both in AQL and in the language of the Murphi model checker . Other output formats are possible, such as Verilog or BlueSpec, but given We have used the Murphi output to verify that PipeGen produces pipelines that correctly enforce the specified MCMs. We have explored combinations of three different single-core pipeline designs (Designs 1, 2, and 3), two different MCMs (x86TSO and ARMv8), and three MCM enforcement mechanisms (i.e., the three transformations from Section 4).
But before discussing the verification results, we show sample output generated by PipeGen to convey a feel for the automation performed.
6.1 Example Output generated by PipeGen
In this section, we show sample output generated by PipeGen for Design-3. Recall that in Design-3 loads can issue to the memory system out-of-order from the load buffer (LB), violating the Load → Load ordering. (We consider a design which has precisely one entry in the LB.) We use PipeGen to enforce this ordering using the In-order (IO) transformation.
At first look, manual IO enforcement might look trivial for this situation: stall the issue of a load to the memory system until all earlier (in program order) loads complete. An architect manually implementing this transformation might be tempted to implement this at the LB since that is where loads are issued to the memory system. But as discussed in Section 4.1 this could lead to a deadlock.
Why? Let us consider two loads, ld1 and ld2, with ld1 before ld2 in program order. Suppose ld2's address resolves first and it enters the LB. Now, if the IO enforcement were implemented at the LB, then the issue of ld2 would have been stalled until the earlier ld1 has its result from the memory system. But ld1 will never be able to enter the LB as that space is occupied by ld2.
This example illustrates that even a seemingly simple enforcement method like IO can be tricky when specializing for different pipelines. As discussed earlier, PipeGen identifies that loads do not enter the LB in program order and therefore searches "backwards" to identify a suitable structure where IO can be safely implemented. In Design-3, that structure is the issue queue (IQ).
Listing 2 shows the "before" and "after" versions of the issue queue for a load instruction (the "after" parts are shown in blue). As can be seen, the original pipeline code simply dispatches the load to the LB when the LB unit is ready (lines 22-28). PipeGen identifies the IQ as a suitable structure to enforce IO. It then adds the code to check whether there are undispatched (to the LB) prior loads (lines . This is a simple associative search within the entries of the IQ as shown. We argue that with the knowledge of this output snippet, it should be a fairly easy task for the architect to implement these changes in any hardware design language such as Verilog. In summary, this example illustrates that: (1) Even seemingly simple transformations are not easy to specialize for a given pipeline;
(2) PipeGen's automatic transformation solves this problem; and (3) It is relatively straightforward for an architect to look at the PipeGen output to implement the changes in any HDL.
6.2 Verification Methodology
We run litmus tests to check if all orderings allowed by the MCM are possible and all orderings disallowed by the MCM are impossible. By using Murphi to "run" the litmus tests we ensure that each litmus test is explored exhaustively (i.e., every possible interleaving of instructions is tested). While litmus testing is not a complete proof, it is widely used and quite effective.
The litmus tests we run cover multi-core orderings, checking that the algorithms have added the orderings required by x86TSO and ARMv8. The basic litmus tests are MP (Message Passing), Dekker's, LB (Load Buffering), and n7, where we additionally run several barrier variants of MP, LB, and Dekker's to test barrier instruction orderings required by x86TSO and ARMv8. A barrier instruction may be between instructions in the Dekker's, LB, and MP litmus tests, where stores and loads may be releases and acquires.
MP litmus test. The message passing (MP) litmus test is shown in Table . In MP, with standard stores and loads, Core 1's reads should not be able to read 1 and 0 in r1 and r2, respectively, if Store → Store and Load → Load are enforced.
Dekker's litmus test. The Dekker's litmus test is shown in Table . If Store → Load is enforced, then reading the results 0 and 0 in both cores is not possible, but it is possible if that ordering is relaxed.  LB litmus test. The load buffering LB litmus test is shown in Table . If Load → Store is enforced, then reading 1 in both cores is not possible, but is possible if the ordering is relaxed.
N7 litmus test. The n7 litmus test is in Table . In this test, a LSQ that has a post-commit WB and that enforces Load → Load, but does not enforce Store → Load, permits (a) Core 0 reading 1 into r1 and reading 0 into r2 and (b) Core 2 reading a 1 into r1 and 0 into r2. The second load in Core 0 thus reads from address y before Core 1's store writes to y, and after it writes to y, Core 2's first load reads from y. Then the second load reads 0 from x as Core 0's store is in its SB.
As TSO includes the mfence instruction, we exhaustively test all combinations of load and store instructions with an mfence added between the instructions, resulting in 7 litmus tests per design. Similarly, ARMv8 introduces LDAR, STLR, DMB SY, DMB ST, and DMB LD, resulting in 22 litmus tests per design after adding litmus test variations of MP, LB, and Dekker's with these ARMv8 fence instructions.
6.3 Transformation Combinations Used in Experiments
PipeGen can apply three different transformations, described in Section 4, and it can apply them in isolation or in combinations. We consider three combinations:
• In-order memory instructions only. The in-order memory instruction transformation can be used to provide any ordering that is desired. • In-order memory + load replay. This combination uses load replay to provide some orderings (M → Load) and in-order memory for the rest. • In-order memory + invalidation tracking. This combination uses invalidation tracking to provide some orderings (M → Load) and in-order memory for the rest.
In Table , we show how we use these three transformation combinations for a cross-product of the three designs and two MCMs we consider in this evaluation. As there are 3 LSQ microarchitectures, and 3 combinations of transformations to evaluate on each microarchitecture for each MCM (TSO and ARMv8), we litmus test 9 experiments per MCM. Across TSO and ARMv8, we litmus test the 7 and 22 litmus tests respectively from Section 6.2 experiment, for a total of 63 and 198 litmus tests.
6.4 Results for Design 1
Design-1 lets loads and stores in any order (that does not violate single-thread correctness), and as a result, it does not enforce Load → Load, Store → Store, or Store → Load orderings. Design-1 does enforce Load → Store though, as loads have completed their access when they commit, and stores have not yet been issued to the memory system when they commit.
6.4.1 Verifying Transformation Combinations that Enforce TSO.
The results corroborate that all of the generated pipelines behave as expected, allowing the allowable litmus test outcomes and disallowing the prohibited outcomes. Unlike some other design/MCM pairs we discuss later, the transformations do not cause any overly conservative orderings.
6.4.2 Verifying Transformation Combinations that Enforce ARMv8.
The results are shown in Table , where most expected behaviors are exhibited, except for the grey cells. The enforced MCM is slightly stronger than the ARMv8 MCM. Specifically, in the Dekker's litmus test with an added DMB ST fence, transformation combinations with Invalidation Tracking and Load Replay both enforce Store → DMB-ST → Load. This is because DMB-ST stalls until prior stores complete, and loads following the DMB-ST can only commit after the DMB-ST commits. With invalidation tracking and load replay taking care of misspeculated loads, this results in Store → DMB-ST → Load to be enforced.
6.5 Results for Design 2
Design-2 is similar to Design-1 in terms of the orderings it enforces, except that without a post-commit WB, stores are executed inorder at commit. Loads still execute out of order and forward from older stores. Thus Design-2 enforces Load → Store by default (like Design-1) but also Store → Store because of the lack of a WB. 6.5.1 Transformation Combinations to Enforce TSO. Design-2's single LSQ disallows the weaker orderings (in the yellow cells of Table ) from the litmus tests when tested with the Load Replay and Invalidation Tracking transformations, even for Dekker's and n7, as Design-2 has no post-commit WB, resulting in Store → Load being enforced. (Different from grey cells, the yellow cells indicate that while the relevant orderings are disallowed by PipeGen, the orderings would also have been disallowed by any manual enforcement technique. Thus, yellow cells are disallowed not because of the conservatism demonstrated by PipeGen but because of the design itself.) 6.5.2 Algorithms Combinations to Enforce ARMv8. Shown in Table , Design-2 with only the in-order algorithm applied meets the expected orderings, except in the event of Dekker's with the DMB LD barrier (the grey cell) which behaves stronger than required; this is because the load is stalled until the barrier is committed which can't commit until the store completes. With invalidation tracking and load-replay the test results (the yellow cells) are all disallowed as there is no post-commit WB, causing the two mechanisms to add Load → Load and Store → Load, as loads' speculation is validated after older stores complete.
6.6 Results for Design 3
Although Design-3 is different from Design-2 (microarchitecturally speaking), like Design-2, it also enforces Store → Store and Load → Store by default (and violates the other two orderings) while also relaxing Store → Load for the same address. Therefore, the results that we observe for Design-3 are identical to those observed for Design-2 in enforcing x86TSO as well as ARMV8 (Tables ), except for N7 that makes use of Store to Load forwarding in its allowed outcome.
6.7 Summary
In summary, our results show that PipeGen always generates pipelines that adhere to the intended MCM; i.e., our generated pipeline never violates the intended MCM. In a couple of examples (involving fences -the grey cells) PipeGen shows slightly stronger behavior than what the intended MCM would show.