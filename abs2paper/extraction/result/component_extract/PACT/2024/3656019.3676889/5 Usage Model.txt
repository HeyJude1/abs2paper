5 Usage Model
In the last section we discussed the three transformations used for enforcing a given MCM. How does the architect specify what transformations to employ? More generally, what is the usage model of PipeGen? Conceptually, PipeGen takes as input a single-threaded pipeline and the MCM and produces a pipeline that enforces the MCM. More concretely, the input pipeline is expressed in AQL, our DSL. What about the MCM? The MCM is expressed as a MOST table which is a standardized format for expressing the memory orderings enforced by the MCM. For example, the MOST table for x86TSO specifies that TSO enforces the Load → Load, Load → Store, and the Store → Store orderings, and the fact that an x86TSO fence instruction, mfence, is ordered with loads, stores, and other mfences.
PipeGen first employs extensive litmus testing to determine what orderings are already enforced by the input pipeline. For example, in most input pipelines, the Load → Store ordering is enforced by default because stores are only allowed to issue to the memory system after any previous loads commit. For the orderings that are not enforced by default, PipeGen must enforce them. But the architect must specify which transformation to use for enforcing each ordering.
We introduced three transformations in the previous section: inorder (IO), load replay (LR), and invalidation tracking (IT). As we discussed in the previous section, IO is the most flexible and can enforce all 4 combinations of memory orderings and fences. LR and IT can enforce the M → Load ordering (where M is a load, store, or fence). Therefore, for every ordering in the MOST table, PipeGen could potentially offer a choice if that ordering can be enforced by both IO and LR/IT. The architect should then specify what transformation must be employed for enforcing that ordering guarantee. We leave this to the architect because they are in the best position to make this choice depending on the type of pipeline. As an extreme example, consider an input pipeline that is not speculative and uses a post-commit write buffer which can violate the Store → Load ordering. In such a pipeline it makes sense to use only the IO transformation because of the lack of speculative capabilities in the original pipeline. We show the MOST table for the x86TSO processor in Table . As we can see, there are three choices for enforcing the Load → Load ordering; the architect chooses one of them. The Load → Store ordering happens to be already enforced and is indicated in the table. Other entries follow a similar pattern.