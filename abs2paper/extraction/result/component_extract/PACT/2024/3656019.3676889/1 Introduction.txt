1 Introduction
Designing a modern, high-performance processor pipeline is a difficult challenge. In the pursuit of performance, cores often seek additional improvements by executing instructions out-of-order. Out-of-order execution must not affect single-threaded functionality, though, and thus microarchitects use structures like the reorder buffer (ROB) and load-store queue (LSQ) to ensure the illusion of in-order behavior for a given hardware thread.
In addition to single-threaded correctness, another key challenge is ensuring that a processor comprised of multiple highperformance cores maintains the desired memory consistency model (MCM). It is very difficult to reason about the possible interleavings of reads (loads) and writes (stores) across threads on different cores and whether they are allowed by the MCM. An architect may design an optimization but fail to realize its full potential on the enforced MCM , or more worryingly, make a design error that leads to the desired MCM no longer being enforced .
In this work, we create the PipeGen design automation tool to address this design challenge. Specifically, PipeGen enables an architect to design a pipeline in an MCM-oblivious fashion, needing only to enforce single-threaded correctness. The architect specifies the single-core design using a new microarchitectural domain specific language (DSL) that we have developed for this purpose. PipeGen then transforms that pipeline into a multicore pipeline that enforces the specified MCM, as illustrated in Figure . A key insight is that we can achieve this automation as code analysis and transformations in a DSL, borrowing methods from compiler design. PipeGen currently uses transformations that encode three different ways of enforcing memory ordering in the pipeline. PipeGen enables microarchitects to focus on designing their core, while offloading the burden of correctly implementing the MCM to our automation tool. PipeGen additionally decouples the implementation of the ISA and MCM, reducing the work necessary to enforce a different MCM. In the history of microarchitectures and MCMs, it has not been uncommon to move between ISAs that use different MCMs, as Apple has done between IBM, x86TSO, and now ARMv8. PipeGen creates the possibility of designing an efficient microarchitecture, and being able to reuse it across different MCMs by using our algorithms to enforce the desired MCM.
Our DSL is tailored for specifying the structures that comprise a microarchitecture. The primary structures are queues that contain one or more entries, such as the reorder buffer (ROB) and load-store queue (LSQ). As such, we refer to our DSL as "A Queue Language" (AQL). Within these queues, the architect specifies the controller state machines that describe the behaviors of these structures. Crucially, we require the architect to identify and label certain key memory instruction states to facilitate PipeGen's automation.
PipeGen's output is a transformed core, described in AQL, that supports the specified MCM. Our key contribution is a set of three compiler-like transformations implementing three different methods of enforcing memory ordering (in-order memory instructions, load replay, and invalidation tracking). While the methods are well known, our innovation here is to codify this domain knowledge into transformations, allowing us to instantiate these on any single-core pipeline expressible in AQL. With the variety of different pipeline microarchitectures being implemented across the different types of processors, this style of design automation has the potential for broad applicability and impact.
We verify that PipeGen correctly produces these cores by automatically translating the output AQL into the language of the Murphi model checker and performing model checking on specific so-called litmus tests . We have verified PipeGen for a variety of core models and MCMs. While other backends are possible -e.g., to hardware description languages such as Verilog -we leave them for future work.
While there has been much work on verifying that a given pipeline core correctly enforces the specified MCM, the most recent of which is the *-Check suite of tools , our point of departure is that our work is a correct-by-construction approach to generating pipelines. This correct-by-construction methodology has seen a recent resurgence for generating coherence protocols and single-core processors but ours is the first to automate the generation of MCM implementations to our knowledge. We discuss related work more extensively in Section 7.
Our contributions are:
• We have created PipeGen, a methodology and a tool for automatically transforming a single-core pipeline into a multicore pipeline that adheres to a given MCM. • PipeGen consists of a DSL called AQL and a set of compilerlike analyses and transformations. Through these transformations, we codify, for the first time, three well-known methods for enforcing memory orderings. This codification allows us to instantiate these methods automatically on any given single-core pipeline expressible in AQL.
• We have validated PipeGen on 3 different pipeline implementations to enforce 2 different memory models (x86TSO and ARMv8) using 3 different methods for enforcing memory ordering (in-order issue, load replay or invalidation-tracking). These were validated in the Murphi model checker exhaustively running litmus tests. Our results show that PipeGen produces multicore pipelines that correctly support the specified MCMs.