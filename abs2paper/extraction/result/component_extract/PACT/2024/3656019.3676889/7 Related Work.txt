7 Related Work
Verification. There has been a rich history of verifying processor pipelines using theorem proving and model checking . Each of these techniques verify a model of the processor, typically expressed as a state machine, and verify it against the instruction set specification. More recently PipeCheck uses the ùúáspec representation of pipelines to verify the MCM orderings of a pipeline using exhaustive litmus testing. For each litmus test, PipeCheck constructs a happens-before graph of the memory instruction events, and a cycle in this graph corresponds to whether an outcome is Table : Three tested ordering mechanism combinations per design. Each combination is either IO (In-order), IO + LR (using IO and Load Replay), and IO + IT (using IO + Load Replay). An ordering may already be enforced (Y) or unenforced (N). *Design 3 does not enforce Store to Load for the same address.
Ld ‚Üí Ld Ld ‚Üí St St ‚Üí St St ‚Üí Ld Ld ‚Üí mF St ‚Üí mF mF ‚Üí Ld mF ‚Üí St mF ‚Üí mF Design 1, TSO IO IO + LR IO + IT IO LR IT Y Y Y IO IO IO N N N Y Y Y IO IO IO IO LR IT Y Y Y Y Y Y Design 2, TSO IO IO + LR IO + IT IO LR IT Y Y Y Y Y Y N LR IT Y Y Y Y Y Y IO LR IO Y Y Y Y Y Y Design 3, TSO IO IO + LR IO + IT IO LR IT Y Y Y Y Y Y N* LR IT Y Y Y Y Y Y IO LR IO Y Y Y Y Y Y ARM Orderings Ld ‚Üí Ld Ld ‚Üí St St ‚Üí St St ‚Üí Ld LDA ‚Üí Ld, LDA LDA ‚Üí St, STR Ld, LDA ‚Üí STR St, STR ‚Üí STR Ld,
IO IO + LR IO + IT N LR IT Y Y Y N N N N N N IO LR IT Y Y Y Y Y Y IO IO IO Y Y Y IO LR IT IO IO IO Y Y Y Y Y Y Design 2, ARM IO IO + LR IO + IT N LR IT Y Y Y Y Y Y N LR IT IO LR IT Y Y Y Y Y Y Y Y Y Y Y Y IO LR IT IO IO IO Y Y Y Y Y Y Design 3, ARM IO IO + LR IO + IT N LR IT Y Y Y Y Y Y N* LR IT IO LR IT Y Y Y Y Y Y Y Y Y Y Y Y IO LR IT IO IO IO Y Y Y Y Y Y
disallowed. This is similar to Herd , where cycles in memory instruction executions indicate a disallowed outcome. In contrast to pipeline verification, our work is focused on the top-down correctby-construction generation of pipelines, in which we add the required MCM orderings, rather than verifying that an existing pipeline correctly enforces MCM orderings.
Hardware Description Languages. Our work is related to hardware description languages such as Verilog, VHDL, Chisel , and Bluespec , in that we share the end goal of generating hardware designs. The point of departure of our work is that our approach is not general: our goal is geared towards generating processor pipelines as opposed to general hardware designs; in fact, our DSL is specialized to processor pipelines, and our transformations take advantage of this domain knowledge.
Microarchitecture Description Languages. Our work is most closely related to what we call microarchitecture description languages. These works raise the level of abstraction of microarchitecture design by using a DSL for expressing aspects of microarchitecture and using compiler technology to lower it to hardware. The earliest example of this is the Teapot language for generating coherence protocols. Other early works raised the level of abstraction of processor pipelines for single-core processors . This area has had a recent resurgence. With open instruction sets and the advent of hardware startups, there is a demand for faster, more reliable and cheaper microarchitecture design. ProtoGen proposes a DSL for synthesizing cache coherence protocols that are correct by construction, and they also use model checking to verify the synthesized protocols. PDL , proposes a pipeline description language and supports limited out-of-order execution. But PDL does not support multicore processors and as a consequence does not help enforce MCMs. To summarize, ours is the only approach to our knowledge that automates the generation of MCMs at the pipeline level.