7 Conclusion
In this work, we introduce a static transformation that separates the use of pointers as handles to data containers from their use as iterators. This improves code analyzability and data-centric compilers are shown to benefit from this transformation as eliminating indirection exposes additional parallelization opportunities. Using our approach on the Mantevo HPCCG benchmark, we were able to match the developer-optimized version and even surpass it by up to 6%. On the OpenSSL PBKDF2 implementation, we were able to automatically parallelize it and obtain up to an 11× speedup.
Appendix
A Proof Sketch of Pointer Assignment
We want to show that the assignment of pointers gives equivalent results after the application of the adjunct transformation described in Figure . To do so, we introduce a new pointer q with its q ad j . Let n, m be arbitrary integers, then we define X , Y and X , Y as
X = (p := p + x i |x i ∈ Z, 0 ≤ i < n) Y = v i := v i + x i |x i ∈ Z & v i ∈
{p, q}, n ≤ i < m X = p ad j := p ad j + x i |x i ∈ Z, 0 ≤ i < n Y = v i ad j := v i ad j + x i |x i ∈ Z & v i ad j ∈ {p ad j , q ad j }, n ≤ i < m . Using ; to concatenate commands, we define S with S = (X ; (q := p; Y )), where it represents the execution of an arbitrary number of pointer movement statements followed by a pointer assignment and another arbitrary number of pointer movement statements. In the same way, we define S as the adjunct transformation of S. S = (X ; (q := p; (q ad j := p ad j ; Y )))
Note that the ; operator is right associative. Then, we define Y q as Y q = m i=n |v i ad j =q ad j
x i , i.e., the difference of value after executing Y on q ad j . Then, (Y ; q ad j ) = q ad j +Y q . Note that X and X only act on p and p ad j , respectively. This is to have a simpler proof, but it can be easily shown that by defining X and X in a similar way as Y and Y , the same result will be obtained.
For the sake of a shorter syntax and more readable proof, we omit the declaration of the pointers and adjunct integer variables. i.e., (p := malloc(...); (p ad j := 0; (q := malloc(...); (q ad j := 0; (S; q))))), as it will be carried without modifications through all the proof steps. Then, we can derive S; q = X ; (q := p; (Y ; q)) (adjunct transformation) = X ; (q := p; (q + (Y ; q ad j )))
(distributive) = X ; ((q := p; q) + (q := p; (Y ; q ad j ))) (no effect statement) = X ; ((q := p; q) + (Y ; q ad j )) (assignment) = X ; (p + (Y ; q ad j )) (distributive) = (X ; p) + (X ; (Y ; q ad j )) (adjunct transformation) = ((X ; p) + (X ; p ad j )) + (X ; (Y ; q ad j )) (no effect statement) = p + (X ; p ad j ) + (X ; (Y ; q ad j )) (no effect statement) = p + (X ; p ad j ) + (Y ; q ad j ) (sum expantion of adjunct) = p + (X ; p ad j ) + q ad j + Y q (adjunct value of 0) = p + (X ; p ad j ) + Y q (no effect statement) = p + (X ; p ad j ) + (X ; Y q ) (distributive) = p + (X ; (p ad j + Y q )) (no effect statement) = p + (X ; (q := p; (p ad j + Y q )))
(assignment) = p + (X ; (q := p; (q ad j := p ad j ; q ad j + Y q ))))