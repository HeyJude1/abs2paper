3 Limitations
The method we propose can provide compilers with better insights into pointer behavior, but only in certain scenarios. In this section, we go into detail as to the limitations of our approach. The main limitation is about the static decidability of which data container a pointer is pointing to. But, we argue that in those cases an algorithm redesign would be needed for any performance improvement.
The necessity of static decidability arises from the utilization of DaCe as the compiler/framework for optimizations. Although DaCe achieves significant performance improvements, particularly in automatic parallelization, it relies on the ability to statically determine data containers. However, the adjunct transformation itself encounters limitations primarily associated with higher-order pointers, as elaborated on in Section 3.2.
Another important aspect to highlight is the utility of our adjunct transformation. Simply exposing additional information to the compiler does not guarantee a runtime performance improvement. In earlier examples, we demonstrated how the compiler generates fewer instructions or eliminates branches entirely. Additionally, using DaCe, it created further parallelization opportunities. We discovered that these improvements are predominantly seen in codes where pointers are used as iterators. While this pattern is common in many codebases, as we will discuss in Table , no immediate improvements will be offered to codes that do not exhibit this pattern.
3.1 Static Decidability
A first assumption is that a pointer has to always point to a statically decidable data container in any given section of the code. This is required to be able to deterministically identify data accesses. Conditional reassignment introduces uncertainty as to which data container a pointer is pointing to. In such cases, our analysis backs off and does not generate an adjunct. However, unconditional or static pointer re-assignments are supported, as they are not introducing uncertainty as to which data container they point to. We can see two code snippets that show this difference in Figure .  With this assumption, we achieve flawless aliasing detection, as the compiler possesses static knowledge of the data container associated with each pointer. Detecting accesses to the same data simply involves verifying if the data container and indices are identical. Leveraging the adjunct transformation streamlines index comparison to a straightforward integer check, often allowing for static analysis if the abstract model is sufficiently precise.
It would be possible to expand the transformation to also support conditional pointers reassignment by creating adjunct versions for each container and replicating the branch decision for each subsequent access. However, this would create unsustainable code and memory replication requirements.
3.2 Pointing to Pointers
Double pointers-or higher-order pointers-are supported by applying the transformation recursively, as can be seen in Figure . Note that the data container to which p is pointing to is statically known. As with simple pointers, we can trace the accesses and to container a ( ) and get the correct adjunct in this case. But the decidability issue remains, as we can see in Figure (left side), where the data container that is accessed is determined by the higher-order pointer location.
The general case could be handled with arrays of adjunct, as shown in Figure (right side). However, trying to leverage this approach on general codes would substantially increase the complexity of the code and consume a significant amount of memory. Note that this approach was not implemented because of the unsustainability of the transformation. Therefore, if additional assumptions can be made about the shape of the individual data containers pointed at, then more targeted, efficient approaches can be used, as explained in Section 4.
Although a multidimensional array shares the same memory representation as higher-order pointers, the analysis differs. Our aim is to eliminate pointer movements and replace them with more predictable array accesses. With multidimensional arrays, this pattern is inherent, and our transformation results in code similar to what is typically observed, as pointers are generally not relocated from multidimensional arrays. Prior proposals have suggested transformations to flatten multidimensional arrays into a single dimension . This approach was also included in GCC between version 4.3 and 4.8. The method is orthogonal to ours and can be applied before or after our transformation, as it will not introduce additional pointer movements.
3.3 Evaluating Applicability
In our investigation, we have identified the primary constraint of the adjunct transformation: higher-order pointers. The requirement for statically decidable data containers is only a prerequisite of the DaCe framework and not of the adjunct transformation itself. To gauge the broader viability of the transformation, we conducted an assessment of its utilization in extensive codebases, specifically focusing on the handling of higher-order pointers.
It is important to clarify our criteria for identifying non-applicable instances. We categorize higher-order pointer usage as constraining only when it potentially involves pointer iteration. Notably, we exempt instances where double pointers are employed to delegate memory allocation responsibilities to another function (refer to Figure ). Moreover, we exclude considerations of the argv parameter in main functions due to its typically diminutive size and minimal involvement in computationally intensive tasks. Our analysis considers application source code, omitting unit tests and examples. Furthermore, our scope is confined to C and C++ files. In the same way, we count single pointers as possible candidates for the adjunct transformation.
The outcomes of our investigation are presented in Table . Our examination encompassed OpenSSL , notable for its cryptographic algorithm implementations, TurboBench [7], which hosts a plethora of compression algorithm implementations, and the Linux kernel [4].
Higher-order pointers are indeed common in these codebases, as expected. However, their frequency is generally several orders of magnitude lower than the total code volume and notably even lower than single order pointer instances. It is essential to note that the provided statistics encompass pointers not exclusively used as iterators. This assessment offers a preliminary insight into the method's broader applicability, highlighting the prevalence of single pointers compared to their higher-order counterparts in programs.  4 From Generic to Specific-Refinements for Practical C Codes We will show how our approach towards improving the analyzability of pointers used as iterators benefits real codes. However, we discovered that for such codes, further refinements are needed such as additional transformations and support for pointers to external calls. All transformations in the following subsections were implemented and are done automatically by the compiler.