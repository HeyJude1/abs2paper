4 Improving Analyzability by Restructuring Data
As discussed in Section 3, pointing to pointers is a more difficult to analyze scenario, as conditional pointer movements can lead to static undecidability regarding which data container is accessed. However, if additional information is known, then the data structures themselves can be changed to make analysis easier. As this kind of transformation targets a general structure, they do not only target a specific program but the entire set of programs that use that structure. An example of a structure transformation that we implemented is inside the Mantevo HPCCG benchmark. It uses sparse matrix storage, specifically the List of Lists (LIL) format. The matrix is stored using two lists for each row containing the column indices and the non-zero values. The row lists are stored as continuous data, and pointers to them are used to access the correct location based on the current row. In Figure , we show the initialization code for a data structure from the HPCCG benchmark (modified for simplicity).
The matrix is accessed using those two lists, as it can be seen in Figure for a matrix-vector multiplication from the same benchmark. With the knowledge that there exists a statically known maximum number of non-zeroes per row, we can transform the list of lists into a matrix, as when the data is accessed (like in , we see that the access resembles a 2D array. We transform the initialization of the sparse matrix to utilize a 2D-like structure instead of a contiguous list. The transformation is shown in Figure . Thanks to this change, we now have data stored in a more regular pattern (2D array). This enables compilers to apply standard transformations and optimizations on 2D containers.  The transformation is done first by finding two pointer assignments working on the same struct inside the same scope ( and ). We use a map to relate the right side of the assignment with the left (curvalptr to A->ptr_to_vals[currow]). We then create an adjunct and transform the code in a similar way to the general pointer transformation. Using the previously created map, we find all pointer accesses that must be transformed and substitute them with array access using the adjunct. In the same way, we find pointer arithmetic operations and substitute the pointer with the adjunct.
The benefit of using such specific pattern-based transformations is that they can be used in conjunction with our general algorithm and therefore be integrated into the same workflow. This creates the possibility to efficiently handle a wide range of other access patterns without the need for separate workflows or manual code modification.
It is important to note that for multidimensional arrays, allocating a continuous buffer and then splitting it by storing pointers introduces uncertainty for static analysis, as explained in Section 3.2. Such patterns are unsupported by our current method. However, our LIL transformation automatically converts this pattern into a 2D array. In other scenarios, implementing additional transformations may be necessary to align with the limitations of our method.
4.2 Handling External Calls with Pointer Arguments
Some parts of a program, such as external library calls, are outside the scope of static compiler analysis. These must therefore be considered black boxes. A common pattern in C when calling external functions is to use pointers as arguments for inputs and outputs. One such example is the memcpy function from the C standard library. The function with the following signature: void* memcpy(void* destination, const void* source, size_t num); takes two pointers and an integer num and copies num bytes from the source pointer to the destination.
In the previous section, we discussed the possible modifications and movement of pointers and their impact on decidability. In the example of memcpy, pointers are not modified. In C, arguments are passed by copy and not by reference, therefore callee modifications of arguments are not propagated to the caller. The same argument applies to pointers. What is modified in those cases is the content of the pointer, hence the elements of the data container that the pointer is pointing to. A function taking a pointer as an argument can modify its contents. This poses a challenge, as data dependencies can no longer be tracked. In Figure , we use memcpy instead of a simple assignment.
On the left side of the figure, the data in p depends on the value previously written to it by memcpy (dependency shown by the dashed arrow). This enforces that the loop must be executed in order. If we remove this dependency (dashed arrow), then loop iterations would be independent. This would permit the compiler to vectorize the loop producing the incorrect result.
We previously assumed that the second argument of memcpy is only read, but this is an insight gained by looking at the implementation of memcpy and not black-box analysis. Without outside information, no compiler framework can overcome this issue. In the right side of Figure , q is only read from, but the compiler cannot infer this. This creates a spurious data dependency between iterations and prevents the loop from being parallelized.
While it is good practice to make pointer arguments that are read-only const, not every function or library does so. Our solution is to use whitelists for often-used library calls-manually annotating library functions to specify if a pointer is write-only, read-write, or read-only. This whitelist could become a database of known functions that could even be automatically populated through compiler analysis, as it only needs to be performed once for any given library implementation. Annotations only provide information about which data container was read or written. We, therefore, assume conservatively that the entire data container could be read or written.
4.3 Stateful External Calls
Some libraries store an internal state that is opaque to the program calling functions provided by the library-great examples being MPI or OpenGL. One such library is a part of OpenSSL, namely, HMAC (Hash Message Authentication Code)-it uses an internal state to store hashes and keys between calls. This data is saved in an internal data structure and a pointer to it is provided to calling functions. This pointer (called context in this implementation) is never modified by the user code, but only by library calls.
HMAC_CTX *hctx = HMAC_CTX_new(); 1 for (...) { HMAC_CTX_copy(hctx, base_hctx); 2 // do operations with hctx } HMAC_CTX_free(hctx);
In the example above, without any additional information, it appears that the hctx pointer is initialized outside the loop ( ) and that the call to HMAC_CTX_copy within the loop ( ) could read and write to hctx. This creates a data dependency between loop iterations. In reality, HMAC_CTX_copy does not read the data of the first argument (hctx)-that value is only written to and effectively used as a local variable within the scope of the loop. Therefore, by marking the dependency on (hctx) in HMAC_CTX_copy as write-only and noticing that it is never used afterwards, the loop can be parallelized. This approach essentially performs an escape analysis , identifying that the variable within the loop does not escape the thread executing each iteration.