2 Background
2.1 UI Rendering
Among all applications running on mobile systems, the currently active applications on the screen are TOP-APPs. UI rendering is the process of displaying frames generated from the TOP-APP on the screen. Mobile systems typically render frames at a stable rate (Frames per Second (FPS)). For example, when the FPS is 60, each frame should be rendered within 16.7 ms (i.e., 1,000 ms/60). Frames that take longer than 16.7 ms to render are janky frames. They cause frame drops and hinder UI smoothness. Consecutive frame drops seriously hurt the mobile user experience. As illustrated in Figure , the UI rendering pipeline has several steps that require the collaboration of the CPU and GPU . Low CPU or GPU frequency can prolong the frame rendering time, leading to janky frames. When rendering a frame, CPU processing and GPU processing consume approximately 87% and 13% of the time, respectively. Therefore, CPU processing is the performance-critical stage.
2.2 ARM big.LITTLE Heterogeneous Architecture
The ARM big.LITTLE heterogeneous architecture is widely employed in recent smartphone processors . It offers the possibility to optimize the UI smoothness and power consumption 12:4 X. Dou et al.  simultaneously. For example, Table shows the device specification used in this study. The Snapdragon 888 processor has eight cores that can be grouped into three clusters with different clock speeds and L2 cache capacities . Specifically, CPU cluster 0 includes four little cores (4×Cortex-A55, cores 0 to 3); CPU cluster 1 includes three middle cores (3×Cortex-A78, cores 4 to 6); CPU cluster 2 includes one big core (1×Cortex-X1, core 7). For all cores in each cluster, their frequency and lower and upper frequency limits can be one of several predefined discrete values. For instance, Snapdragon 888's CPU cluster 0 has 16 discrete frequency levels, ranging from 300 MHz to 1,804.8 MHz. Figure shows how single-core power consumption varies with the increase of processor frequency in each CPU cluster. We have two key observations: The cores in CPU cluster 0 are power-saving ones. They can achieve a similar frequency with much lower power consumption than cores in CPU clusters 1 and 2. (2) For some CPU clusters (e.g., cluster 1 or 2 in Figure ), the increase of power consumption can be sharp with the frequency increases. Thus, in terms of scheduling, the power-saving CPU clusters and frequency levels should be better utilized to reduce power consumption.
2.3 Tunable Knobs on Mobile Systems
Android OS has multiple mechanisms for developers to control performance and power consumption, e.g., sched_boost, core_ctl, CPUFreq, and devfreq. These mechanisms are important to MobiRL 12:5 system developers. Critical applications can temporarily receive a higher CPU scheduling priority by configuring the boost policy in the sched_boost mechanism . The core_ctl mechanism can be used to adjust the maximum and minimum number of cores for each CPU cluster. However, we observe that both sched_boost and core_ctl have risks of causing system performance fluctuations. For example, improper configurations of sched_boost may lead to high context switching overheads; disabling CPU cores using the core_ctl mechanism may result in frame drops and slow responsiveness due to insufficient computing resources. Therefore, they should be used carefully.
In our work, we use the CPUFreq and devfreq subsystems in the OS kernel to adjust CPU frequency and GPU frequency. CPUFreq and devfreq subsystems provide editable configuration files that manage each CPU cluster and GPU, including the governor being used, upper frequency limit, lower frequency limit, and so forth. For the CPUFreq subsystem, the governor is used to dynamically adjust the CPU cluster's frequency according to CPU resources required by individual tasks or task groups. For example, when the frequency update is triggered, Android's default governor schedutil adjusts the CPU frequency dynamically to control the estimated CPU utilization close to 80%. If the estimated CPU utilization is above 80%, it dynamically scales up the CPU frequency if possible; otherwise, if utilization is below 80%, it scales down the CPU frequency. The value of the upper frequency limit is the maximum frequency that a CPU cluster can achieve; the value of the lower frequency limit is the minimum achievable frequency. For the devfreq subsystem, the governor and frequency limits work in the same way for GPU. Raising the frequency limits can improve UI smoothness but may incur high power consumption. Conversely, lowering them saves power but may incur frame drops and hinder UI smoothness. By adjusting the frequency limits and observing the feedback from the mobile system, MobiRL learns to optimize UI smoothness and power consumption simultaneously on the fly.