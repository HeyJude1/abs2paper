3 Motivation
Smartphone users may tap or swipe the screen at any time, leading to bursty inputs, and thus, system loads fluctuate. To meet user demands promptly, the existing frequency scheduling approach that is widely used in mobile devices raises the lower frequency limits of the CPU to predefined values when the screen is being touched to handle high system loads . It also raises the frequency limits when applications are launched to reduce launch time. Through this approach, the actual running frequency of the processors will not fall below these lower limits. We use this approach as the baseline in this study. However, it does not work well in some cases. An example is shown in Figure . In this example, we use TikTok as the TOP-APP and Android debug bridge (adb) to simulate users' swipe actions. In Figure , (a) through (d) share the same x-axis. Figures ) through 3(c) show the frequency changes for each CPU cluster. In Figure (a), the dot curve line represents the frequency at CPU cluster 0 runs. The black solid curve represents CPU cluster 0's upper frequency limit-the maximum frequency that CPU cluster 0 can achieve. The gray solid curve represents CPU cluster 0's lower frequency limit. CPU cluster 0 has 16 predefined discrete frequency values (y-axis) indicated by the horizontal dashed lines in Figure (a), ranging from 300 MHz to 1,804.8 MHz. The lower and upper frequency limits of CPU cluster 0 can be one of these predefined values. When the TOP-APP is launched, the existing approach sets the lower frequency limit of CPU cluster 0 to a predefined value of 691.2 MHz and sets the upper frequency limit to 1,804.8 MHz. When the screen is swiped at frame 12, 44, 69, and 92 (highlighted in Figures )), the existing approach increases CPU cluster 0's lower frequency limit to 902.4 MHz (highlighted in the left part in Figure ). The frequency boost will be over when the swipe action ends. Figures ) and 3(c) show the frequency changes of CPU cluster 1 and 2 during this period, respectively. The lower frequency limits of CPU cluster 1 and 2 are also raised to predefined values when the screen is touched. We record the rendering time for each frame, as 12:6 X. Dou et al. Fig. . An example showing the existing approach heuristically boosting the frequency when the user swipes the screen. The hardware is with the latest smartphone delivered by a well-known mobile company (Table ).
shown in Figure . Frames with a rendering time higher than the allowed frame rendering time (15.7 ms) are considered janky frames (highlighted in red). Through this example, we can find two shortcomings in the existing frequency scheduling approach:
(1) Cannot handle some high-load cases that are not directly triggered by users' actions. The existing approach is merely designed to tackle the cases where users launch an application or touch the screen. When the system's high loads are not directly caused by launching a new application or touching the screen, the existing approach may fail to handle themit cannot promptly boost the processors' frequency to satisfy the loads. For example, the current approach fails to address the loads from frame 18 to frame 44 caused by video playing in Figure . At frame 18, TikTok switches to the following video. The video triggers data downloads, video decoding, and memory accesses (not brought by the user's direct actions, e.g., touching, etc.), bringing high loads for the mobile system. The existing approach fails to boost the processor's frequency to handle these loads in these cases, leading to consecutive frame drops as shown in Figure .
(2) Computing frequency under/over-provision for dynamically changing loads. The existing approach often does not adjust the processors' frequency according to system loads' requirements. Instead, it boosts the processors' frequency by raising the lower frequency limit according to predefined rules. For instance, in Figures ) through 3(c), the existing approach raises the lower frequency limits (gray solid curve) of each CPU cluster to 902.4 MHz, 960 MHz, and 1,075.2 MHz (predefined values), respectively, when the screen is being touched/swiped. In frame 93, the system has a high load caused by the swipe action. However, though the lower frequency limits are raised to predefined values in each processor cluster (illustrated in the right of Figures )), it is still insufficient to satisfy the load, resulting in three consecutive janky frames (right part in Figure ). This is the frequency under-provision. Moreover, by contrast, raising the frequency to predefined values may lead to over-provision (a higher frequency than necessary), leading to increased power consumption.
To sum up, on mobile systems, user behaviors may change every second, and scheduling computing frequency to satisfy users' demands can be challenging. Searching in the solution space of processors' frequency for every possible combination of frequency limits (e.g., upper/lower frequency limits) can be difficult. An ideal frequency scheduling mechanism should be able to adjust frequency limits according to system loads accurately. We think that leveraging ML is an ideal approach as it can handle complicated cases with low overheads . So, we want to have a new ML-based frequency scheduling approach, which adjusts processors' frequency on demand according to system loads by a reinforcement learning-based approach, avoiding janky frames for UI smoothness and saving power.