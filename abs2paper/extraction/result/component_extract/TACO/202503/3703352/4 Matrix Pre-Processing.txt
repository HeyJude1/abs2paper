4 Matrix Pre-Processing
In this section, we describe the matrix pre-analysis and matrix splitting steps. We propose lightweight analysis algorithms and sparsity splitting rules to generate panels associated with the distribution features of NZs.
4.1 Matrix Pre-Analysis
Many works design multiplication algorithms for matrices with different NZs features. The result is that they incur high latency to analyze the distribution of NZs. For example, Rasouli et al. not only count the NNZs in rows and columns for diagonal matrices, but also calculate the NNZs and positions on the diagonal. While the overhead of computing diagonal NNZs and positions is tolerable for small matrices, it becomes quite time-consuming for larger matrices and loses scalability on general matrices. Therefore, we need to extract as little information as possible without considering the NZs distribution features.
For each input matrix, we methodically extract the following pertinent information: (a) the NNZs in each row of matrix A, (b) the NNZs in each row of matrix B, and (c) the NNZs within each column of matrix A.
By utilizing the prefix sum algorithm for the inherent rowptr index in matrix A, we can quickly determine the number of NNZs in each row. Similarly, we can obtain the NNZs for each row in matrix B.
Furthermore, owing to the inherent characteristic of the CSR format wherein NZs within the same column share identical indexes in the "colptr", we can expediently determine the NNZs present in each column.
The collected information will guide the optimization of the next three steps. Further elucidation of the utilization of this critical information is expounded upon in subsequent sections of this academic exposition.
4.2 Matrix Splitting
To categorize the distribution of NZs features effectively, we use a sparsity criterion denoted as S. It splits the matrix into two distinct categories-sparse panels and dense panels-based on the level of sparsity. Sparsity S is defined as the ratio of NNZs to the total number of elements in the matrix. Specifically, for a given row i in the matrix with a total number of elements denoted as E i and NNZs as N NZ i , S is formally expressed as the quotient N NZ i /E i .
During the splitting of rows within matrix A, a crucial step involves reordering these matrices, as an example in Figure . Specifically, first, the sparsity S for each row is computed using information obtained from the matrix pre-analysis step. Subsequently, a descending order reorder of all the rows in matrix A based on their respective S is carried out using a simple and efficient Quick Sort algorithm, while ensuring the retention of "colptr" and "data" lists in matrix A. Although Quick Sort is unstable, it only alters the relative positions of indexes with the same S, which does not affect the splitting of the matrix. Similarly, matrix B is also reordered based on the S. It's worth noting that our reordering operations pertain exclusively to the matrix indices, optimizing reordering efficiency. Following the reordering, rows with S exceeding the row sparsity threshold P are classified as dense panels, otherwise, they are classified as sparse panels. In most applications, a matrix is considered sparse if the proportion of NZs is less than 5%. Therefore, P is typically valued at 0.05.  . The S and P are the sparsity and row sparsity thresholds, respectively. The S value for each row is calculated through its NNZs, which are obtained from the prefix sum algorithm in the matrix pre-analysis step. The matrix is reordered in descending order based on sparsity. The "rowptr" is reordered to get the new matrix "rowptr", and the "rowind" stores the row index of the old matrix corresponding to the new matrix.
After the reordering, the matrices A and B are now organized into distinct components known as dense panels and sparse panels. During computation, three types may arise: multiplication of sparse panels by sparse panels (SpGEMM), multiplication of sparse panels by dense panels (SpMM), and multiplication of dense panels by dense panels (DGEMM). It's important to note that while we refer to these components as panels, the operations within them are essentially matrix multiplications. We use symbols A p and B p to refer to panels from matrices A and B. Subsequent sections of this article will detail optimization techniques relevant to these three distinct types of panel multiplication.