4 Motivation and Overview 4.1 Motivation Example
As a motivation, we consider the construction time released in the latest Graph500 rankings , as shown in Tables . According to Graph500 specification , the GTEPS is the ranking . Similarly, the top-ranked Wuhan Supercomputer and Pengcheng Cloudbrain-II respectively take milliseconds to process the SSSP kernel while consuming 16,285 seconds (equivalent to 4.52 hours) and 57,218 seconds (equivalent to 15.89 hours) to construct graphs before entering SSSP, as shown in Table .
Although these systems win top-ranked throughout when processing graph operators, they wait up to tens of hours to ingress. It severely conflicts with the QoS according to Equation (2) and damages the experience of large-scale HPC systems. Breakdown. Figure illustrates communication and computation, including synchronization times per testing scale for Graph500 BFS. Communication time is split into the time of calling send/recv, allgatherv, and alltoallv. As the number of parallel nodes increases, communication overhead grows, while computation time decreases due to enhanced parallelism in graph processing. However, increased node counts can result in communication becoming a significant bottleneck in the overall program execution time. The total communication time, i.e., the accumulative time of send/recv, allgatherv, alltoallv and synchronization, can be up to 87% when running large-scale BFS on 65,536 computing nodes on the latest Tianhe supercomputer . The main reasons are that (i) current systems ignore communication hierarchies, resulting in expensive communication costs and (ii) there is substantial irregular memory access and prior solutions failing to leverage access coalesce.  For example, the intra-domain communication is about 0.1μs, but inter-domain communication is increased by almost 10 times for one layer. Thus, the communication cost between CPUs 1 and 2 is 0.1μs, between CPUs 1 and 3 is 1μs, and between CPUs 1 and 5 is 10μs. Given that one CPU can accept one graph vertex for computing, traditional methods are used to balance the workload for each domain, as shown in Figure
(c): a → 1, b → 3, c → 5, d → 2.
According to the communication costs mentioned above, the total communication cost is 1μs(a : b) + 10μs(a : c) + 1μs(b : d) = 12μs. This is a sub-optimal assignment. If we are aware of the hierarchical topology of the target HPC system, we can come up with a better solution, which is shown in Figure
): a → 1, b → 3, c → 2, d → 4.
To this end, the final communication cost is 1μs(a : b) + 0.1μs(a : c) + 0.1μs(b : d) = 1.2μs. By doing so, communication costs can be reduced by orders of magnitude. This is a motivation of GraphService to orchestrate data layout for expediting graph construction. Coalescing access. In addition to communication topology boosting graph construction, CSR transformation can also batch memory access to further advance graph construction. Many realworld and mimic graphs are sparse and exhibit a skewed distribution, where many vertices have the same degree . However, CSR-like formats only differ zero values from non-zero elements and then record all non-zero entries of the matrix. Specifically, there is a key regarding the row index array, RST, when using CSR to store the adjacency matrix of a sorted graph. Vertices with the same edge degree have adjacent lists stored in a contiguous manner in the COL array. We further observe that identical-degree vertices constitute a large proportion of real-life graphs, implying that they take up most of the storage space. Figure shows how the vertices distribute in two real-world graphs, clueweb12 and twitter2010. Whereas clueweb12 owns 978,408,098 vertices and GraphService: Topology-aware Constructor for Large-scale Graph Applications 2:9 has a sparsity (i.e., non-zero degree vertices ratio) of 90.5%, twitter2010 owns 41,652,230 vertices and has a sparsity of 86.7%. In Figure , we show that accumulative 1-degree (i.e., in-degree and out-degree) vertices are up to 49.57% and 16.03% of the total vertices, respectively, for clueweb12 and twitter2010. Interestingly, the same-degree distribution does not vary significantly with the sparsity of the graph though the number of zeros decreases as the graph gets denser. More details of the vertices distribution can be referred to TianheGraph . This gives us an extra dimension of motivation to develop GraphService for batching and coalescing memory accesses with memory reduction. Lessons learned. The experimental results demonstrate the limitations of current graph processing engines in constructing graphs although they give excellent throughput. It also highlights the need to build an ultra-fast constructor, including a communication hierarchy-aware partitioner and a space-time-efficient graph compression.
4.2 Preliminaries
Definition 4.1 (Computing Node (CN)). A computing node (CN), denoted as C, represents a kind of device in the exascale cluster that is responsible for message computing.
Definition 4.2 (Routing Cell (RC)
). An RC, denoted as R, represents a kind of device in the largescale HPC systems that is responsible for transferring messages between CNs, which can be further classified into leaf RC and high-level RC. A leaf RC is the lowest level of RC, which is responsible for the lowest level of message communication for CNs. High-level RC is responsible for message communication among RCs.   In practice, the communication costs differ a lot among intra-and inter-domain communications. For example, the intra-domain communication cost can be 1 unit, i.e., cost intr a = 1 U, the interdomain communication cost between D 0 * and D 1 * can be 10 U. Given a graph G = (V , E) and a large-scale hierarchical system (i.e., Exa), we can split and distribute G into a total of s subgraphs P s (G). An ultra-fast constructor aims to orchestrate the P s (G)
Definition 4.5 (Graph). A graph is denoted as
G = (V , E), where V is a set of vertices, v i ∈ V represents the i-th node, and N = |V | is the total number of vertices in G; E ⊆ V × V represents a set of edges, e i = (v j , v k ) ∈ E denotes a connection from v j to v k .
GraphService: Topology-aware Constructor for Large-scale Graph Applications 2:11 into different CNs for graph operators ingressing for the best QoS by minimizing the construction time. It can be formulated as follows.
Θ(QoS) ≈ min τ д + τ c (3)
Owing to τ д τ c , the construction time (i.e., τ c ) is dominated by communication cost as shown in Figure so that Equation (4) can be approximated as follows.
min
N i=1 N j=1 ComCost(v i , v j ), subject to v i , v j ∈ Exa.CNs, ( 4
)
where N is the total number of vertices in G and Exa.CNs refers to the set of CNs belonging to Exa. ComCost(v i , v j ) is the message communication cost between v i and v j , which are distributed into CNs equipped in the Exa.