3 AgileWatts Architecture
Before presenting AgileWatts (AW) , we first describe the characteristics of the architecture for a Skylake-based processor. Figure (a) presents the floorplan of a Skylake-based server processor (SKX). The processor's main components are the core tiles, the on-die-fabric, the north cap , and the memory controllers. The on-die-fabric, which is organized as a mesh network, connects all main components of the architecture. The core tiles, which cover most of the chip's area, contain all resources of the core domain including some resources of the uncore domain (see Figure ). Specifically, the core domain contains the CPU core, AVX extension, and private caches (see Figure )), and the uncore domain of the core tile contains the caching-and-homeagent (CHA), last-level-cache (LLC), and snoop filter (SF). The north cap, which is the area located at the top of the die, consists of the IO agents (i.e., PCIe, UPI, and DMI), the serial ports, the clock generator unit, the fuse units, and the global power management unit. Finally, the die contains two memory controllers on the left and right columns. Since AW optimizes the core C-state architecture, we emphasize on the differences between Skylake and AW on the core domain (see Figure ).
This work extends the initial version of AW (i.e., C6A/C6AE) and introduces two new core deep idle power states: C6Awarm and C6AwarmE, which aim to optimize both the transition and cold-start latency while achieving significant power savings. C6A and C6AE (i.e., initial version ) optimize only the transition latency of deep idle power states. Additionally, in the initial version of AW, the L1I & Fetch/Prefetch chip area (see Figure ) is power gated, whereas in C6Awarm is kept into retention mode.
C6Awarm (C6A Agile warm) has close to zero-watt power consumption and nanosecond-scale entry/exit latency which allows servers running latency-critical applications to enter it during short and irregular idle periods. C6AwarmE (C6 Agile warm Enhanced, analogous to C1E) is a lower-power variant of C6Awarm that reduces additional leakage power by lowering core voltage to a minimum operational level. The discussion focuses on the C6Awarm design and operation and points out the differences with C6AwarmE when relevant.
The C6Awarm state is based on two key ideas: Units' Fast Power Gating (UFPG) (Section 3.1 ) and a Cache Coherence and Sleep Mode (CCSM) (Section 3.2 ). The new power management flow that coordinates the UFPG and the CCSM at nanosecond granularity is presented in Section 3.3 .
3.1 Units' Fast Power Gating
AW UFPG is a low-latency power gating architecture that shuts off most of the core units while retaining the context in place, thus enabling a transition latency of tens of nanoseconds. Conventional context retention techniques (see C6 C-state flow in Figure ) sequentially save/restore the context to/from external SRAM before/after power gating/ungating . This process adds several microseconds (e.g., 5-10 µs) to the entry/exit latency. Instead, AW retains the context in place, completely removing that overhead at a very small additional idle power cost.
AW enables in-place context retention with a medium-grained power gating approach. In coarsegrained PG (used in Skylake client cores), the entire core is under the same power gate and context is saved/restored externally. Our approach is based on the power gating for the AVX-256 and AVX-512 core units in recent server and client cores. These power gating techniques require only 10-20ns to power gate/ungate a unit because they power and retain the unit's context in place and avoid having to save and restore it externally.
AW's medium-grained power gating for C6Awarm and C6AwarmE applies to the majority of the core units (shaded red in Figure ) and excludes the L1 and L2 caches (instruction and data), their controllers (handled separately in Section 3.2 ), and the branch predictors along with their controllers (see Figure (c), L1I Fetch/Prefetch).
Within the medium-grained PG region, AW uses multiple techniques to retain the context in place and enable fast (several nanoseconds) transition latency. The context of a CPU core is ∼8 kB and falls into two categories: (i) registers (i.e., configuration and status registers (CSRs) or fuse registers) and (ii) SRAMs (i.e., firmware persistent data and patches) . We discuss Agile C-States: A Core C-State Architecture for Latency Critical Applications 66:11 next three techniques that AW uses to retain the context during C6Awarm; the first two apply to registers and the third to SRAM.
Placing Unit Context in the Ungated Domain . One option to retain the context of a power-gated unit is to place its registers outside the power-gated region (i.e., in the core's ungated domain). This option is suitable for units with small context (e.g., execution units); Intel likely uses this technique for the AVX execution units . AW uses this technique for all core units that require only a local context to be retained-that is, this is not applicable to a unit with a distributed context that is impractical to relocate to a centralized ungated region. The following units satisfy this requirement: (1) all execution units (not AVX), (2) execution ports, and (3) the out-of-order engine.
State Retention Power Gates . Moving distributed or large context to a separate ungated area is impractical (e.g., timing and wiring constraints). For this reason, AW employs a different retention technique-State Retention Power Gates (SRPGs) -for units that contain such context. SRPG is a special flip-flop fed with two supplies: power gated and power ungated. Such a flip-flop typically contains a shadow flip-flop to retain its state when the unit it resides in is power gated . Intel uses this technique in the chipset to retain the state of autonomously power-gated units .
Place SRAM Context in Ungated Power Supply . Part of the CPU core context is located in SRAMs . While the microcode firmware is stored in read-only memory, known as microcode sequencer ROM (MS-ROM), microcode patches and data are stored in an ∼2KB SRAM . This SRAM is initialized at boot time and should be retained when power gating the microcode unit. The C6 exit flow re-initializes the content of this SRAM from the core's S/R SRAM in a separate ungated uncore domain; this process is sequential and can take several microseconds . AW avoids the need to re-initialize the microcode patch SRAM by powering it with a separate core ungated supply.
3.2 Cache Coherence and Sleep Mode
To avoid the high transition latency (tens of microseconds) to flush private caches (i.e., L1D and L2) and the high cold-start latency (see Section 2 ) to warm up the microarchitectural state of the core (branch predictors, L1I ∼ L1I & Fetch/Prefetch, see Figure )), AW keeps them power ungated (see Figure )) when transitioning to C6Awarm. This has two design implications: first, AW needs to employ other power-saving techniques to reduce the power of the cache/L1I & Fetch/Prefetch domain, and second, a core in C6Awarm state still needs to serve coherence requests .
AW employs two techniques to reduce the power consumption of the power-ungated private cache/L1I & Fetch/Prefetch domain. First, unless a coherence request is being served, AW keeps these domains clock gated to save its dynamic power. Second, AW leverages the cache sleep mode technique , which adds sleep transistors to the SRAM arrays of private caches and branch predictors. The sleep transistors reduce the SRAM array's supply voltage to the lowest level that can retain the SRAM content while significantly reducing leakage power.
Since private caches are not flushed when a core enters C6Awarm, AW must allow the core to respond to snoop requests . AW keeps the logic required to handle cache snoops in the power-ungated (clock-gated) domain with the private caches. It also uses minimal logic ( same with C1 ) to detect incoming snoop requests in an always-active (i.e., not power/clock-gated) domain. As soon as this logic detects incoming snoop traffic, it increases the SRAM array voltage through sleep transistors and re-activates the clock of the private caches until the snoop requests are served.
3.3 AW Power Management Flow
AW implements the C6Awarm/C6AwarmE flow within the core power management agent (PMA) . This flow, shown in Figure , orchestrates the transitioning between the C0 and C6Awarm/C6AwarmE C-states and handles coherence traffic while in the C6Awarm/C6AwarmE state.
Similar to other C-states, the operating system triggers C6Awarm entry by executing the MWAIT instruction . The first step clock gates the UFPG domain (Section 3.1 ) and keeps the core phase-locked loop (PLL) on. When entering C6AwarmE, the PMA initiates a non-blocking transition to Pn. Subsequently , the flow saves (in place) the UFPG domain context and shuts down its power. Additionally , the flow puts L1I cache and branch predictors into sleep mode and clock gates the domain. Finally , the flow sets the private caches into sleep mode (Section 3.2 ) and shuts down their clock, putting the core into C 6 Aw arm/ C 6 Aw armE state.
When a snoop request arrives, the PMA activates the private caches to respond. First, the flow clock ungates the cache domain and adjusts its supply voltage to exit sleep mode . At this point , the caches can handle the snoop requests. Finally , PMA rolls back the changes in reverse order and brings the core back into C 6 Aw arm/ C 6 Aw armE state once all snoops are serviced.
When an interrupt occurs, the core exits from C 6 Aw arm/ C 6 Aw armE and goes back into C0 (active) state. The exit flow is simply the reverse process of the entry flow. First , the flow clock ungates L1/L2 and exits sleep mode . The flow also clock ungates the L1I-branch predictor and exits sleep mode. Next , it power ungates the UFPG units and triggers the restore signal to the SRPG flops. Finally , the flow clock ungates UFPG units, bringing the core to the C0 active state.