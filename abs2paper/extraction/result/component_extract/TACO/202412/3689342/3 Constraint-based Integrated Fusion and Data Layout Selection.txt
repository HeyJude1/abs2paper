3 Constraint-based Integrated Fusion and Data Layout Selection
Our approach aims to generate a concrete implementation of a given contraction tree by automatically determining (1) the order of modes in the data layout of each tensor and (2) a structure of fused loops that minimizes the order of intermediate tensors. We formulate a constraint system that answers the following question: For the given contraction tree, does there exist an implementation for which all intermediate tensors are of order at most l, for some given integer l? We first ask this question for l = 1 . If the answer is positive, the constraint system solution is used to construct a code implementation for the contraction tree. If the answer is negative, we formulate and solve a constraint system for l = 2 , seeking a solution in which all intermediates are at most 2-D matrices. This process continues until we find a solution. Note that a trivial solution without any fusion is guaranteed to exist for a sufficiently large value of l.
In each of these steps, we employ the Z3 SMT solver to provide either (1) a negative answer ("the constraint system is unsatisfiable") or ( ) a positive answer with a concrete constraint solution that defines the desired tensor layouts and loop structure. The generated constraints are based on quantifier-free integer difference logic. While in general the search space is exponential in CoNST: Code Generator for Sparse Tensor Networks 82:9 the number of contractions and the number of indices, our experience shows that Z3 solves the generated constraint systems with very practical running times (as detailed in Section 5 ).
3.1 Input and Output
The input to our approach is a set of contractions {C 0 , C 1 , . . . , C m−1 } organized in a contraction tree. Each leaf node corresponds to an input tensor reference, the root node corresponds to a result tensor reference, and every other node corresponds to an intermediate tensor reference. As an example, the contraction tree for A naive implementation of a given tree would contain a sequence of perfectly nested loops (one loop nest per contraction), based on some valid topological sort order of tree nodes. For each contraction, the loop nest would be some permutation of the set of indices that appear in the tensor references, and the loop body would be a single assignment. For example, the loop nest for X i jqr = A ipq × B jpr would contain loops for r , q, i, j, and p in some order.
X i jqr = A ipq × B jpr ; Y i jkr = X i jqr × C kqr ; R i jk = Y i
As discussed earlier in Section 2 , for any (unfused or fused) implementation, a fundamental constraint is that the order of surrounding loops must match the data layout order of modes in the CSF tensor representation. This is needed to allow for efficient iteration over the sparse representation. For example, consider reference A ipq . Recall from the earlier discussion that each index is mapped to the corresponding mode of A: i is mapped to d 0 , p is mapped to d 1 , and q is mapped to d 2 . A concrete implementation would select a particular order of d 0 , d 1 , and d 2 as the outer, middle, and inner level in the CSF representation, respectively. For example, suppose that this order is, from outer to inner, d 1 , d 2 , d 0 . In the code implementation, the tensor reference would be A[p,q,i] . Efficient iteration over elements of A would require that the loop structure surrounding the reference matches this order: the p loop must appear before the q loop, which must appear before the i loop. The constraint-based approach described below incorporates such constraints for the loops that surround (in a fused code structure) each tensor reference from the contraction tree.
Each of the fused loop structures we would like to explore can be uniquely defined by (1) a topological sort order of the non-leaf nodes in the contraction tree and (2) for each such node, an ordering of the indices that appear in it. The index order for a node defines the order of loops that would surround the corresponding assignment in the fused loop nest. This order also defines the CSF layout order for the corresponding tensors.
For example, consider the code structure in Figure , which is derived from the solution of our constraint system for the running example. Here there is a single valid topological sort for the assignments. The ordering of surrounding loops for the assignments is r , j, p, q, i , r , j, q, k, i , and r , j, k, i , respectively. The fusion of the common r and j loops allows X and Y to be reduced to 2-D tensors. The order of indices in all tensor references is consistent with the order of surrounding loops.
3.2 Constraint Formulation
The space of targeted code structures is encoded via constraints over integer-typed constraint variables, as described below.
3.2.1 Ordering of Assignments.
For each contraction C i , the position of the corresponding assignment relative to the other assignments in the code is encoded by a constraint variable ap i (short for "assignment position for C i ") such that 0 ≤ ap i < m, ap i ap k for all k i, and ap i < ap j if C i is a child of C j in the contraction tree. Here m is the number of contractions. The first two constraints guarantee uniqueness and appropriate range for all ap i . The last constraint ensures a valid topological sort order.
Example. For the running example, we have ap 0 for X i jqr = A ipq × B jpr , ap 1 for Y i jkr = X i jqr × C kqr , and ap 2 for R i jk = Y i jkr × D jkr . For this contraction tree (Figure ) the only valid topological sort is C 0 , C 1 , C 2 and thus the only possible solution is ap i = i. In a more general tree, there may be multiple valid assignments of values to ap i , each corresponding to one topological sort order.
3.2.2 Ordering of Tensor Modes.
For each order-n tensor T that has references in the contraction tree, and each mode d j of T ( 0 ≤ j < n), we use a constraint variable dp T , j to encode the position of d j in the CSF layout of the tensor. The following constraints are used: 0 ≤ dp T , j < n and dp T , j dp T , j for all j j. Any constraint variable values that satisfy these constraints define a particular permutation of the modes of tensor T and thus a concrete CSF data layout.
Example. In the running example, A has three modes and thus three constraint variables dp A,0 , dp A,1 , and dp A,2 . In the code structure shown in Figure , abstract tensor reference A ipq is mapped to concrete reference A[p,q,i] . This corresponds to the following assignment of values to the constraint variables: dp A,0 = 2 , dp A,1 = 0 , and dp A,2 = 1 . Thus, the outermost level in the CSF representation corresponds to mode d 1 (indexed by p), the next CSF level corresponds to d 2 (indexed by q), and the inner CSF level corresponds to d 0 (indexed by i).
3.2.3 Ordering of Loops.
Next, we consider constraints that encode the fused loop structure. For any contraction C i , we need to encode the loop order of the loops surrounding the corresponding assignment. Let In i be the set of indices that appear in C i . For each k ∈ In i , we define an integer constraint variable lp i,k (short for "loop position of index k for C i "). These variables will encode a permutation of the elements of In i , that is, a loop order for the loops surrounding the assignment for C i . If lp i,k has a value of 0, index k will be the outermost loop surrounding the assignment. If the value is 1, the index will be the second-outermost loop, and so forth. To encode a permutation, for each k ∈ In i we have constraints 0
≤ lp i,k < | In i | and lp i,k lp i,k for all k ∈ In i \ { k } .
Example. In the running example, for contraction C 0 : X i jqr = A ipq × B jpr we have In 0 = {i, j, p, q, r }. For this contraction we will use constraint variables lp 0 ,i , lp 0 , j , lp 0 ,p , lp 0 ,q , lp 0 ,r . In the code structure shown in Figure , the loop order for C 0 is r , j, p, q, i . This order corresponds to a constraint solution in which lp 0 ,i = 4 , lp 0 , j = 1 , lp 0 ,p = 2 , lp 0 ,q = 3 , and lp 0 ,r = 0 .
3.2.4 Consistency between Mode Order and Loop
Order. Next, we need to ensure that the order of loops defined by lp i,k is consistent with the order of modes for each tensor appearing in contraction C i , as encoded by dp T , j . Consider a reference to T appearing in contraction C i . For each pair of modes d j and d j of T , let k and k be the indices that correspond to these modes in the reference. The following constraint enforces the consistency between mode order and loop order:
(dp T , j < dp T , j ) ⇒ (lp i,k < lp i,k ).
Here dp T , j < dp T , j is true if and only if mode d j appears earlier than mode d j in the concrete CSF data layout of tensor T . If this is the case, we want to enforce that the index corresponding to d j (i.e., k) appears earlier than the index corresponding to d j (i.e., k ) in the loop order of loops surrounding the assignment for C i . As discussed earlier, this constraint ensures that the order of iteration defined by the loop order allows an efficient traversal of the CSF data structure for T . Such constraints are introduced for all input tensors. For intermediates that are represented through dense workspaces, such constraints are not necessary. In our implementation, we use dense workspaces for all intermediates.
Example. Consider reference A ipq from the running example and the pair of modes d 0 and d 2 , with corresponding indices i and q. The relationship between variables dp A,0 (for d 0 ), dp A,2 (for d 2 ), lp 0 ,i (for i), and lp 0 ,q (for q) is captured by the following two constraints:
(dp A,0 < dp A,2 ) ⇒ (lp 0 ,i < lp 0 ,q ) (dp A,2 < dp A,0 ) ⇒ (lp 0 ,q < lp 0 ,i ).
As described earlier, in the constraint solution we have dp A,0 = 2 , dp A,2 = 1 , lp 0 ,i = 4 , and lp 0 ,q = 3 . Of course, these values satisfy both constraints.
3.2.5
Producer-consumer Pairs. Finally, we consider every pair of contractions C i , C j such that C i is a child of C j in the contraction tree. In this case C i produces a reference to a tensor T that is then consumed by C j . Let n be the order of T . Our goal is to identify a loop fusion structure that reduces the order of this intermediate tensor T to be some n ≤ l for a given parameter l. Recall that in our overall scheme, we first define a constraint system with l = 1 . If this system cannot be satisfied, we define a new system with l = 2 , and so forth.
Let In T be the set of indices that appear in the reference to T . We define constraints that include lp i,k (for the producer C i ) and lp j,k (for the consumer C j ), for all k ∈ In T . The constraints ensure that a valid fusion structure exists to achieve the desired reduced order n of T .
Producer constraints. First, we consider the outermost n − l indices in the loop order associated with the producer C i and ensure that they are all indices of the result reference. Specifically, for each s such that 0 ≤ s < n − l and for each k ∈ In T , we create terms of the form lp i,k = s and introduce an OR constraint for these terms (illustrated by an example below). This guarantees that the loop at position s in the loop structure surrounding the producer statement is iterating over one of the indices that appear in the result reference. The combination of these constraints for all pairs of s and k ensures that the outermost n − l loops for C i are all indices of its result tensor reference.
Example. Consider reference X i jqr from the running example. This reference is produced by C 0 : X i jqr = A ipq × B jpr and consumed by C 1 : Y i jkr = X i jqr × C kqr . We have In X = {i, j, q, r }. The producer constraints will involve variables lp 0 ,i , lp 0 , j , lp 0 ,q , and lp 0 ,r . Suppose l = 2 . We would like the outermost n − l = 4 − 2 indices in the loop order for C 0 to be indices that access this reference. Together with the remaining constraints described shortly, this would allow those two indices to be removed from the reference after fusion. As a result, the order of X can be reduced from 4 to 2. Two constraints are formulated. First, lp 0 ,i = 0 ∨ lp 0 , j = 0 ∨ lp 0 ,q = 0 ∨ lp 0 ,r = 0 ensures that the outermost loop surrounding the producer is indexed by one of i, j, q, or r . Similarly, lp 0 ,i = 1 ∨ lp 0 , j = 1 ∨ lp 0 ,q = 1 ∨ lp 0 ,r = 1 guarantees that the second-outermost loop is also indexed by one of the indices of X i jqr . For the fused code shown in Figure , we have lp 0 ,r = 0 (i.e., the outermost loop for C 0 is r ) and lp 0 , j = 1 (i.e., the second-outermost loop is j). Thus, in the fused code, the reference to X will only contain the remaining indices i and q, as shown by X[q,i] in Figure .
Consumer constraints. Next, we create constraints for the consumer contraction C j : the sequence of its outermost n − l loops must match the sequence of the outermost n − l loops for the producer C i . This ensures that the same sequence of n − l loops surrounds both the producer and the consumer, which is required for fusion that reduces the order of the intermediate from n to n such that n ≤ n − (n − l) = l. (In case the constraint solver produces a solution for which more than n − l outermost loops can be fused, we can have n < l.) The constraints for C j include, for each s such that 0 ≤ s < n − l and for each k ∈ In T , a constraint of the form (lp i,k = s) ⇒ (lp j,k = s).
Example. For X i jqr and its consumer C 1 , we include constraints connecting lp 0 ,k and lp 1 ,k for each k ∈ {i, j, q, r } for s = 0 (i.e., the outermost loop) and s = 1 (i.e., the second-outermost loop).
Statements between producer and consumer. Finally, we have to consider all assignments that appear between the producer C i and the consumer C j in the topological sort order defined by constraint variables ap i described earlier. For any such assignment, the sequence of the outermost n − l loops that surround it must match the ones for C i and C j . This is needed in order to have a valid fusion structure. The corresponding constraints are of the following form, for each contraction C r with r i and r j, each s with 0 ≤ s < n − l, and each k ∈ In T :
(ap i < ap r < ap j ) ⇒ ((lp i,k = s) ⇒ (lp r,k = s)).