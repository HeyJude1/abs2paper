2 Background
2.1 SpTRSV and Level-Set Method
The SpTRSV solves a linear system Ax = b, where A is the lower triangular matrix of size m × m, b is the dense right-hand-side (rhs) vector, and x is the dense solution vector. Without loss of generality, we assume that the matrix is stored in Compressed Sparse Row (CSR) format in our illustration. The CSR format stores the sparse matrix by three arrays, where ColIdx and V al store the column index and the value of each non-zero, respectively, and RowPtr stores the start point of each row in the above two arrays. An example of a sparse lower triangular matrix is shown on the left-hand side of Figure . In this example, RowPtr = {0, 1, 2, 3, 5, 8, 12, 13, 16} and ColIdx = {0, 1, 2, 0, 3, 1, 2, 4, 0, 3, 4, 5, 6, 1, 6, 7, 4, 7, 8}. The serial SpTRSV algorithm with the CSR format is illustrated in Algorithm 1. Here, we assume that the diagonal elements of each row are present by default. In serial SpTRSV, components of x are calculated in the order of row number. The component x[j] are guaranteed to be finished when calculating x[i], where 0 < j < i < m, the data dependency is thus satisfied.
However, the sequential computing order of serial SpTRSV poses challenges to efficient parallelization. To exploit the parallelism of the problem, the level-set method has been proposed. The level-set method partitions the solution into several levels. A level is composed of components independent of each other. Dependencies may exist among different levels. The right part of Figure shows the level-set partition as a directed computation graph. Each directed edge in the computation graph represents a non-zero element in A, indicating a data dependency relationship. The level-set method solves independent components inside every single level in parallel while processing levels in a sequential order to ensure dependencies.
The level-set method can efficiently exploit parallelism in SpTRSV. However, it requires synchronization at the end of each level to avoid violation of data dependencies. This may introduce extra costs on GPUs with huge amounts of parallel units, especially when the number of levels is large.
2.2 SpTRSV on GPUs
Directly applying level-set methods on GPUs cannot achieve satisfactory performance due to excessive costs for global synchronization. Liu proposed the synchronization-free method using the CSC format. The concept of the synchronization-free method does not imply the complete elimination of synchronization, but rather the replacement of global synchronization in level-set methods with fine-grained point-to-point synchronization. Dufrechou and Ezzatti and Su et al. proposed synchronization-free methods using the CSR format with warp-level and thread-level parallelism, respectively. The two algorithms are designed for matrices with different sparsity patterns. YYSpTRSV dynamically switches between the two algorithms according to the average number of non-zeros per row. Dufrechou and Ezzatti also proposed to process multiple rows with a single warp. The pseudocode of the warp-level and thread-level methods with the CSR format is shown in Algorithm 2, where an auxiliary array named f laд is used to mark the completion of each component. In both methods, memory fences (Line 13 & Line 30) are used to strictly ensure that the flags are updated after the results of the components are written back. In the warp-level method, the non-zeros of each row are partitioned and assigned to different threads (Line 5). A warp-level reduce routine is introduced (Line 11) to sum up the results of each thread. Thread-level method assigns every t rows to a warp and each thread corresponds to one or more rows. t is set as the size of the warp in . As all threads in a single warp follow the same control flow in GPU programming, a while loop is used to avoid deadlock. A more detailed description of the two algorithms can be found in . In this work, we introduce a unified and parameterized template for parallelism (discussed in Section 4.2). As a superset of existing methods, the template extends the design space with finer granularity and exhibits adaptability to different tasks in the solution.